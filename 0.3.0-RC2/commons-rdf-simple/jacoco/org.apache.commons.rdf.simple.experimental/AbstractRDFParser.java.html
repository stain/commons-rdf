<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../.resources/report.css" type="text/css"/><link rel="shortcut icon" href="../.resources/report.gif" type="image/gif"/><title>AbstractRDFParser.java</title><link rel="stylesheet" href="../.resources/prettify.css" type="text/css"/><script type="text/javascript" src="../.resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../.sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Commons RDF: Simple Implementation</a> &gt; <a href="index.source.html" class="el_package">org.apache.commons.rdf.simple.experimental</a> &gt; <span class="el_source">AbstractRDFParser.java</span></div><h1>AbstractRDFParser.java</h1><pre class="source lang-java linenums">/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements. See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership. The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * &quot;License&quot;); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.commons.rdf.simple.experimental;

import java.io.IOException;
import java.io.InputStream;
import java.net.URI;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Optional;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;
import java.util.function.Consumer;

import org.apache.commons.rdf.api.Dataset;
import org.apache.commons.rdf.api.Graph;
import org.apache.commons.rdf.api.IRI;
import org.apache.commons.rdf.api.Quad;
import org.apache.commons.rdf.api.RDFSyntax;
import org.apache.commons.rdf.api.RDF;
import org.apache.commons.rdf.experimental.RDFParser;
import org.apache.commons.rdf.simple.SimpleRDF;

/**
 * Abstract RDFParser
 * &lt;p&gt;
 * This abstract class keeps the properties in protected fields like
 * {@link #sourceFile} using {@link Optional}. Some basic checking like
 * {@link #checkIsAbsolute(IRI)} is performed.
 * &lt;p&gt;
 * This class and its subclasses are {@link Cloneable}, immutable and
 * (therefore) thread-safe - each call to option methods like
 * {@link #contentType(String)} or {@link #source(IRI)} will return a cloned,
 * mutated copy.
 * &lt;p&gt;
 * By default, parsing is done by the abstract method
 * {@link #parseSynchronusly()} - which is executed in a cloned snapshot - hence
 * multiple {@link #parse()} calls are thread-safe. The default {@link #parse()}
 * uses a thread pool in {@link #threadGroup} - but implementations can override
 * {@link #parse()} (e.g. because it has its own threading model or use
 * asynchronous remote execution).
 */
<span class="fc" id="L59">public abstract class AbstractRDFParser&lt;T extends AbstractRDFParser&lt;T&gt;&gt; implements RDFParser, Cloneable {</span>

<span class="fc" id="L61">    public static final ThreadGroup threadGroup = new ThreadGroup(&quot;Commons RDF parsers&quot;);</span>
<span class="fc" id="L62">    private static final ExecutorService threadpool = Executors.newCachedThreadPool(r -&gt; new Thread(threadGroup, r));</span>

    // Basically only used for creating IRIs
<span class="fc" id="L65">    private static RDF internalRdfTermFactory = new SimpleRDF();</span>

    /**
     * Get the set {@link RDF}, if any.
     * 
     * @return The {@link RDF} to use, or {@link Optional#empty()} if it has not
     *         been set
     */
    public Optional&lt;RDF&gt; getRdfTermFactory() {
<span class="fc" id="L74">        return rdfTermFactory;</span>
    }

    /**
     * Get the set content-type {@link RDFSyntax}, if any.
     * &lt;p&gt;
     * If this is {@link Optional#isPresent()}, then {@link #getContentType()}
     * contains the value of {@link RDFSyntax#mediaType}.
     * 
     * @return The {@link RDFSyntax} of the content type, or
     *         {@link Optional#empty()} if it has not been set
     */
    public Optional&lt;RDFSyntax&gt; getContentTypeSyntax() {
<span class="fc" id="L87">        return contentTypeSyntax;</span>
    }

    /**
     * Get the set content-type String, if any.
     * &lt;p&gt;
     * If this is {@link Optional#isPresent()} and is recognized by
     * {@link RDFSyntax#byMediaType(String)}, then the corresponding
     * {@link RDFSyntax} is set on {@link #getContentType()}, otherwise that is
     * {@link Optional#empty()}.
     * 
     * @return The Content-Type IANA media type, e.g. &lt;code&gt;text/turtle&lt;/code&gt;,
     *         or {@link Optional#empty()} if it has not been set
     */
    public final Optional&lt;String&gt; getContentType() {
<span class="fc" id="L102">        return contentType;</span>
    }

    /**
     * Get the target to consume parsed Quads.
     * &lt;p&gt;
     * From the call to {@link #parseSynchronusly()}, this will be a
     * non-&lt;code&gt;null&lt;/code&gt; value (as a target is a required setting).
     * 
     * @return The target consumer of {@link Quad}s, or &lt;code&gt;null&lt;/code&gt; if it
     *         has not yet been set.
     * 
     */
    public Consumer&lt;Quad&gt; getTarget() {
<span class="fc" id="L116">        return target;</span>
    }

    /**
     * Get the target dataset as set by {@link #target(Dataset)}.
     * &lt;p&gt;
     * The return value is {@link Optional#isPresent()} if and only if
     * {@link #target(Dataset)} has been set, meaning that the implementation
     * may choose to append parsed quads to the {@link Dataset} directly instead
     * of relying on the generated {@link #getTarget()} consumer.
     * &lt;p&gt;
     * If this value is present, then {@link #getTargetGraph()} MUST be
     * {@link Optional#empty()}.
     * 
     * @return The target Dataset, or {@link Optional#empty()} if another kind
     *         of target has been set.
     */
    public Optional&lt;Dataset&gt; getTargetDataset() {
<span class="nc" id="L134">        return targetDataset;</span>
    }

    /**
     * Get the target graph as set by {@link #target(Graph)}.
     * &lt;p&gt;
     * The return value is {@link Optional#isPresent()} if and only if
     * {@link #target(Graph)} has been set, meaning that the implementation may
     * choose to append parsed triples to the {@link Graph} directly instead of
     * relying on the generated {@link #getTarget()} consumer.
     * &lt;p&gt;
     * If this value is present, then {@link #getTargetDataset()} MUST be
     * {@link Optional#empty()}.
     * 
     * @return The target Graph, or {@link Optional#empty()} if another kind of
     *         target has been set.
     */
    public Optional&lt;Graph&gt; getTargetGraph() {
<span class="nc" id="L152">        return targetGraph;</span>
    }

    /**
     * Get the set base {@link IRI}, if present.
     * 
     * @return The base {@link IRI}, or {@link Optional#empty()} if it has not
     *         been set
     */
    public Optional&lt;IRI&gt; getBase() {
<span class="fc" id="L162">        return base;</span>
    }

    /**
     * Get the set source {@link InputStream}.
     * &lt;p&gt;
     * If this is {@link Optional#isPresent()}, then {@link #getSourceFile()}
     * and {@link #getSourceIri()} are {@link Optional#empty()}.
     * 
     * @return The source {@link InputStream}, or {@link Optional#empty()} if it
     *         has not been set
     */
    public Optional&lt;InputStream&gt; getSourceInputStream() {
<span class="fc" id="L175">        return sourceInputStream;</span>
    }

    /**
     * Get the set source {@link Path}.
     * &lt;p&gt;
     * If this is {@link Optional#isPresent()}, then
     * {@link #getSourceInputStream()} and {@link #getSourceIri()} are
     * {@link Optional#empty()}.
     *
     * @return The source {@link Path}, or {@link Optional#empty()} if it has
     *         not been set
     */
    public Optional&lt;Path&gt; getSourceFile() {
<span class="fc" id="L189">        return sourceFile;</span>
    }

    /**
     * Get the set source {@link Path}.
     * &lt;p&gt;
     * If this is {@link Optional#isPresent()}, then
     * {@link #getSourceInputStream()} and {@link #getSourceInputStream()} are
     * {@link Optional#empty()}.
     * 
     * @return The source {@link IRI}, or {@link Optional#empty()} if it has not
     *         been set
     */
    public Optional&lt;IRI&gt; getSourceIri() {
<span class="fc" id="L203">        return sourceIri;</span>
    }

<span class="fc" id="L206">    private Optional&lt;RDF&gt; rdfTermFactory = Optional.empty();</span>
<span class="fc" id="L207">    private Optional&lt;RDFSyntax&gt; contentTypeSyntax = Optional.empty();</span>
<span class="fc" id="L208">    private Optional&lt;String&gt; contentType = Optional.empty();</span>
<span class="fc" id="L209">    private Optional&lt;IRI&gt; base = Optional.empty();</span>
<span class="fc" id="L210">    private Optional&lt;InputStream&gt; sourceInputStream = Optional.empty();</span>
<span class="fc" id="L211">    private Optional&lt;Path&gt; sourceFile = Optional.empty();</span>
<span class="fc" id="L212">    private Optional&lt;IRI&gt; sourceIri = Optional.empty();</span>
    private Consumer&lt;Quad&gt; target;
    private Optional&lt;Dataset&gt; targetDataset;
    private Optional&lt;Graph&gt; targetGraph;

    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public T clone() {
        try {
<span class="fc" id="L221">            return (T) super.clone();</span>
<span class="nc" id="L222">        } catch (CloneNotSupportedException e) {</span>
<span class="nc" id="L223">            throw new RuntimeException(e);</span>
        }
    }

    @SuppressWarnings(&quot;unchecked&quot;)
    protected T asT() {
<span class="fc" id="L229">        return (T) this;</span>
    }

    @Override
    public T rdfTermFactory(RDF rdfTermFactory) {
<span class="nc" id="L234">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="nc" id="L235">        c.rdfTermFactory = Optional.ofNullable(rdfTermFactory);</span>
<span class="nc" id="L236">        return c.asT();</span>
    }

    @Override
    public T contentType(RDFSyntax rdfSyntax) throws IllegalArgumentException {
<span class="fc" id="L241">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="fc" id="L242">        c.contentTypeSyntax = Optional.ofNullable(rdfSyntax);</span>
<span class="fc" id="L243">        c.contentType = c.contentTypeSyntax.map(syntax -&gt; syntax.mediaType);</span>
<span class="fc" id="L244">        return c.asT();</span>
    }

    @Override
    public T contentType(String contentType) throws IllegalArgumentException {
<span class="nc" id="L249">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="nc" id="L250">        c.contentType = Optional.ofNullable(contentType);</span>
<span class="nc" id="L251">        c.contentTypeSyntax = c.contentType.flatMap(RDFSyntax::byMediaType);</span>
<span class="nc" id="L252">        return c.asT();</span>
    }

    @Override
    public T base(IRI base) {
<span class="fc" id="L257">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="fc" id="L258">        c.base = Optional.ofNullable(base);</span>
<span class="fc" id="L259">        c.base.ifPresent(i -&gt; checkIsAbsolute(i));</span>
<span class="fc" id="L260">        return c.asT();</span>
    }

    @Override
    public T base(String base) throws IllegalArgumentException {
<span class="nc" id="L265">        return base(internalRdfTermFactory.createIRI(base));</span>
    }

    @Override
    public T source(InputStream inputStream) {
<span class="fc" id="L270">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="fc" id="L271">        c.resetSource();</span>
<span class="fc" id="L272">        c.sourceInputStream = Optional.ofNullable(inputStream);</span>
<span class="fc" id="L273">        return c.asT();</span>
    }

    @Override
    public T source(Path file) {
<span class="fc" id="L278">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="fc" id="L279">        c.resetSource();</span>
<span class="fc" id="L280">        c.sourceFile = Optional.ofNullable(file);</span>
<span class="fc" id="L281">        return c.asT();</span>
    }

    @Override
    public T source(IRI iri) {
<span class="fc" id="L286">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="fc" id="L287">        c.resetSource();</span>
<span class="fc" id="L288">        c.sourceIri = Optional.ofNullable(iri);</span>
<span class="fc" id="L289">        c.sourceIri.ifPresent(i -&gt; checkIsAbsolute(i));</span>
<span class="fc" id="L290">        return c.asT();</span>
    }

    @Override
    public T source(String iri) throws IllegalArgumentException {
<span class="nc" id="L295">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="nc" id="L296">        c.resetSource();</span>
<span class="nc" id="L297">        c.sourceIri = Optional.ofNullable(iri).map(internalRdfTermFactory::createIRI);</span>
<span class="nc" id="L298">        c.sourceIri.ifPresent(i -&gt; checkIsAbsolute(i));</span>
<span class="nc" id="L299">        return source(internalRdfTermFactory.createIRI(iri));</span>
    }

    /**
     * Check if an iri is absolute.
     * &lt;p&gt;
     * Used by {@link #source(String)} and {@link #base(String)}.
     * 
     * @param iri
     *            IRI to check
     * @throws IllegalArgumentException
     *             If the IRI is not absolute
     */
    protected void checkIsAbsolute(IRI iri) throws IllegalArgumentException {
<span class="pc bpc" id="L313" title="1 of 2 branches missed.">        if (!URI.create(iri.getIRIString()).isAbsolute()) {</span>
<span class="nc" id="L314">            throw new IllegalArgumentException(&quot;IRI is not absolute: &quot; + iri);</span>
        }
<span class="fc" id="L316">    }</span>

    /**
     * Check that one and only one source is present and valid.
     * &lt;p&gt;
     * Used by {@link #parse()}.
     * &lt;p&gt;
     * Subclasses might override this method, e.g. to support other source
     * combinations, or to check if the sourceIri is resolvable.
     * 
     * @throws IOException
     *             If a source file can't be read
     */
    protected void checkSource() throws IOException {
<span class="fc bfc" id="L330" title="All 6 branches covered.">        if (!sourceFile.isPresent() &amp;&amp; !sourceInputStream.isPresent() &amp;&amp; !sourceIri.isPresent()) {</span>
<span class="fc" id="L331">            throw new IllegalStateException(&quot;No source has been set&quot;);</span>
        }
<span class="pc bpc" id="L333" title="1 of 4 branches missed.">        if (sourceIri.isPresent() &amp;&amp; sourceInputStream.isPresent()) {</span>
<span class="nc" id="L334">            throw new IllegalStateException(&quot;Both sourceIri and sourceInputStream have been set&quot;);</span>
        }
<span class="pc bpc" id="L336" title="1 of 4 branches missed.">        if (sourceIri.isPresent() &amp;&amp; sourceFile.isPresent()) {</span>
<span class="nc" id="L337">            throw new IllegalStateException(&quot;Both sourceIri and sourceFile have been set&quot;);</span>
        }
<span class="pc bpc" id="L339" title="1 of 4 branches missed.">        if (sourceInputStream.isPresent() &amp;&amp; sourceFile.isPresent()) {</span>
<span class="nc" id="L340">            throw new IllegalStateException(&quot;Both sourceInputStream and sourceFile have been set&quot;);</span>
        }
<span class="fc bfc" id="L342" title="All 4 branches covered.">        if (sourceFile.isPresent() &amp;&amp; !sourceFile.filter(Files::isReadable).isPresent()) {</span>
<span class="fc" id="L343">            throw new IOException(&quot;Can't read file: &quot; + sourceFile);</span>
        }
<span class="fc" id="L345">    }</span>

    /**
     * Check if base is required.
     * 
     * @throws IllegalStateException
     *             if base is required, but not set.
     */
    protected void checkBaseRequired() throws IllegalStateException {
<span class="fc bfc" id="L354" title="All 4 branches covered.">        if (!base.isPresent() &amp;&amp; sourceInputStream.isPresent()</span>
<span class="pc bpc" id="L355" title="3 of 6 branches missed.">                &amp;&amp; !contentTypeSyntax.filter(t -&gt; t == RDFSyntax.NQUADS || t == RDFSyntax.NTRIPLES).isPresent()) {</span>
<span class="fc" id="L356">            throw new IllegalStateException(&quot;base iri required for inputstream source&quot;);</span>
        }
<span class="fc" id="L358">    }</span>

    /**
     * Reset all source* fields to Optional.empty()
     * &lt;p&gt;
     * Subclasses should override this and call &lt;code&gt;super.resetSource()&lt;/code&gt;
     * if they need to reset any additional source* fields.
     * 
     */
    protected void resetSource() {
<span class="fc" id="L368">        sourceInputStream = Optional.empty();</span>
<span class="fc" id="L369">        sourceIri = Optional.empty();</span>
<span class="fc" id="L370">        sourceFile = Optional.empty();</span>
<span class="fc" id="L371">    }</span>

    /**
     * Reset all optional target* fields to {@link Optional#empty()}.
     * &lt;p&gt;
     * Note that the consumer set for {@link #getTarget()} is
     * &lt;strong&gt;note&lt;/strong&gt; reset.
     * &lt;p&gt;
     * Subclasses should override this and call &lt;code&gt;super.resetTarget()&lt;/code&gt;
     * if they need to reset any additional target* fields.
     * 
     */
    protected void resetTarget() {
<span class="fc" id="L384">        targetDataset = Optional.empty();</span>
<span class="fc" id="L385">        targetGraph = Optional.empty();</span>
<span class="fc" id="L386">    }</span>

    /**
     * Parse {@link #sourceInputStream}, {@link #sourceFile} or
     * {@link #sourceIri}.
     * &lt;p&gt;
     * One of the source fields MUST be present, as checked by
     * {@link #checkSource()}.
     * &lt;p&gt;
     * {@link #checkBaseRequired()} is called to verify if {@link #getBase()} is
     * required.
     * 
     * @throws IOException
     *             If the source could not be read
     * @throws RDFParseException
     *             If the source could not be parsed (e.g. a .ttl file was not
     *             valid Turtle)
     */
    protected abstract void parseSynchronusly() throws IOException, RDFParseException;

    /**
     * Prepare a clone of this RDFParser which have been checked and completed.
     * &lt;p&gt;
     * The returned clone will always have {@link #getTarget()} and
     * {@link #getRdfTermFactory()} present.
     * &lt;p&gt;
     * If the {@link #getSourceFile()} is present, but the {@link #getBase()} is
     * not present, the base will be set to the &lt;code&gt;file:///&lt;/code&gt; IRI for
     * the Path's real path (e.g. resolving any symbolic links).
     * 
     * @return A completed and checked clone of this RDFParser
     * @throws IOException
     *             If the source was not accessible (e.g. a file was not found)
     * @throws IllegalStateException
     *             If the parser was not in a compatible setting (e.g.
     *             contentType was an invalid string)
     */
    protected T prepareForParsing() throws IOException, IllegalStateException {
<span class="fc" id="L424">        checkSource();</span>
<span class="fc" id="L425">        checkBaseRequired();</span>
<span class="fc" id="L426">        checkContentType();</span>
<span class="fc" id="L427">        checkTarget();</span>

        // We'll make a clone of our current state which will be passed to
        // parseSynchronously()
<span class="fc" id="L431">        AbstractRDFParser&lt;T&gt; c = clone();</span>

        // Use a fresh SimpleRDF for each parse
<span class="pc bpc" id="L434" title="1 of 2 branches missed.">        if (!c.rdfTermFactory.isPresent()) {</span>
<span class="fc" id="L435">            c.rdfTermFactory = Optional.of(createRDFTermFactory());</span>
        }
        // sourceFile, but no base? Let's follow any symlinks and use
        // the file:/// URI
<span class="pc bpc" id="L439" title="1 of 4 branches missed.">        if (c.sourceFile.isPresent() &amp;&amp; !c.base.isPresent()) {</span>
<span class="fc" id="L440">            URI baseUri = c.sourceFile.get().toRealPath().toUri();</span>
<span class="fc" id="L441">            c.base = Optional.of(internalRdfTermFactory.createIRI(baseUri.toString()));</span>
        }

<span class="fc" id="L444">        return c.asT();</span>
    }

    /**
     * Subclasses can override this method to check the target is valid.
     * &lt;p&gt;
     * The default implementation throws an IllegalStateException if the target
     * has not been set.
     */
    protected void checkTarget() {
<span class="pc bpc" id="L454" title="1 of 2 branches missed.">        if (target == null) {</span>
<span class="nc" id="L455">            throw new IllegalStateException(&quot;target has not been set&quot;);</span>
        }
<span class="pc bpc" id="L457" title="2 of 4 branches missed.">        if (targetGraph.isPresent() &amp;&amp; targetDataset.isPresent()) {</span>
            // This should not happen as each target(..) method resets the
            // optionals
<span class="nc" id="L460">            throw new IllegalStateException(&quot;targetGraph and targetDataset can't both be set&quot;);</span>
        }
<span class="fc" id="L462">    }</span>

    /**
     * Subclasses can override this method to check compatibility with the
     * contentType setting.
     * 
     * @throws IllegalStateException
     *             if the {@link #getContentType()} or
     *             {@link #getContentTypeSyntax()} is not compatible or invalid
     */
    protected void checkContentType() throws IllegalStateException {
<span class="fc" id="L473">    }</span>

    /**
     * Guess RDFSyntax from a local file's extension.
     * &lt;p&gt;
     * This method can be used by subclasses if {@link #getContentType()} is not
     * present and {@link #getSourceFile()} is set.
     * 
     * @param path
     *            Path which extension should be checked
     * @return The {@link RDFSyntax} which has a matching
     *         {@link RDFSyntax#fileExtension}, otherwise
     *         {@link Optional#empty()}.
     */
    protected static Optional&lt;RDFSyntax&gt; guessRDFSyntax(Path path) {
<span class="fc" id="L488">        return fileExtension(path).flatMap(RDFSyntax::byFileExtension);</span>
    }

    /**
     * Return the file extension of a Path - if any.
     * &lt;p&gt;
     * The returned file extension includes the leading &lt;code&gt;.&lt;/code&gt;
     * &lt;p&gt;
     * Note that this only returns the last extension, e.g. the file extension
     * for &lt;code&gt;archive.tar.gz&lt;/code&gt; would be &lt;code&gt;.gz&lt;/code&gt;
     * 
     * @param path
     *            Path which filename might contain an extension
     * @return File extension (including the leading &lt;code&gt;.&lt;/code&gt;, or
     *         {@link Optional#empty()} if the path has no extension
     */
    private static Optional&lt;String&gt; fileExtension(Path path) {
<span class="fc" id="L505">        Path fileName = path.getFileName();</span>
<span class="pc bpc" id="L506" title="1 of 2 branches missed.">        if (fileName == null) {</span>
<span class="nc" id="L507">            return Optional.empty();</span>
        }
<span class="fc" id="L509">        String filenameStr = fileName.toString();</span>
<span class="fc" id="L510">        int last = filenameStr.lastIndexOf(&quot;.&quot;);</span>
<span class="pc bpc" id="L511" title="1 of 2 branches missed.">        if (last &gt; -1) {</span>
<span class="fc" id="L512">            return Optional.of(filenameStr.substring(last));</span>
        }
<span class="nc" id="L514">        return Optional.empty();</span>
    }

    /**
     * Create a new {@link RDF} for a parse session.
     * &lt;p&gt;
     * This is called by {@link #parse()} to set {@link #rdfTermFactory(RDF)} if
     * it is {@link Optional#empty()}.
     * &lt;p&gt;
     * As parsed blank nodes might be made with
     * {@link RDF#createBlankNode(String)}, each call to this method SHOULD
     * return a new RDF instance.
     * 
     * @return A new {@link RDF}
     */
    protected RDF createRDFTermFactory() {
<span class="fc" id="L530">        return new SimpleRDF();</span>
    }

    @Override
    public Future&lt;ParseResult&gt; parse() throws IOException, IllegalStateException {
<span class="fc" id="L535">        final AbstractRDFParser&lt;T&gt; c = prepareForParsing();</span>
<span class="fc" id="L536">        return threadpool.submit(() -&gt; {</span>
<span class="fc" id="L537">            c.parseSynchronusly();</span>
<span class="fc" id="L538">            return null;</span>
        });
    }

    @Override
    public T target(Consumer&lt;Quad&gt; consumer) {
<span class="fc" id="L544">        AbstractRDFParser&lt;T&gt; c = clone();</span>
<span class="fc" id="L545">        c.resetTarget();</span>
<span class="fc" id="L546">        c.target = consumer;</span>
<span class="fc" id="L547">        return c.asT();</span>
    }

    @Override
    public T target(Dataset dataset) {
        @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; })
<span class="nc" id="L553">        AbstractRDFParser&lt;T&gt; c = (AbstractRDFParser) RDFParser.super.target(dataset);</span>
<span class="nc" id="L554">        c.resetTarget();</span>
<span class="nc" id="L555">        c.targetDataset = Optional.of(dataset);</span>
<span class="nc" id="L556">        return c.asT();</span>
    }

    @Override
    public T target(Graph graph) {
        @SuppressWarnings({ &quot;rawtypes&quot;, &quot;unchecked&quot; }) // super calls our
                                                       // .clone()
<span class="fc" id="L563">        AbstractRDFParser&lt;T&gt; c = (AbstractRDFParser) RDFParser.super.target(graph);</span>
<span class="fc" id="L564">        c.resetTarget();</span>
<span class="fc" id="L565">        c.targetGraph = Optional.of(graph);</span>
<span class="fc" id="L566">        return c.asT();</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.eclemma.org/jacoco">JaCoCo</a> 0.7.6.201602180812</span></div></body></html>